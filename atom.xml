<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scorpio</title>
  
  <subtitle>这一刻，与你相遇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-13T14:56:36.975Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>欢仔</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题整理</title>
    <link href="http://yoursite.com/2020/04/13/mian-shi-ti-zheng-li/"/>
    <id>http://yoursite.com/2020/04/13/mian-shi-ti-zheng-li/</id>
    <published>2020-04-13T13:18:13.093Z</published>
    <updated>2020-05-13T14:56:36.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="undefine和null的区别"><a href="#undefine和null的区别" class="headerlink" title="undefine和null的区别"></a>undefine和null的区别</h3><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><blockquote><p>undefined是访问一个为初始化的变量时，这时返回的值就是undefined</p></blockquote><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><blockquote><p>null是访问一个未存在的对象（引用类型），这时返回的值就是null</p><p>因此可以把undefined看作空变量，而null看作空对象</p></blockquote><h3 id="判断一个对象是否是数组"><a href="#判断一个对象是否是数组" class="headerlink" title="判断一个对象是否是数组"></a>判断一个对象是否是数组</h3><blockquote><p>方法1.Array.isArray([])</p><p>方法2. obj instanceof Array  判断对象是否是Array构造函数的实例</p><p>方法3.  5.obj.constructor===Array   //true  判断实例的constructor是否指向Array构造函数</p></blockquote><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><h4 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h4><blockquote><p>当持续触发事件时，一定时间内没有再触发事件，事件函数才会执行一次，如果设定时间到来之前，有触发了一次，那么就重新计算。 也就是说当一个用户一直触发这个函数，且每次触发函数的间隔小于既定时间，那么防抖的情况下只会执行一次。 </p></blockquote><h4 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h4><blockquote><p>当持续触发时，保证在一定的时间内只调用一次事件处理函数，意思就是说，假设一个用户一直触发这个函数，且每次触发小于既定值，函数节流会每隔这个时间调用一次。</p><p>总结：</p><p>用一句话总结防抖和节流的区别：防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行 </p></blockquote><h3 id="常见的浏览器兼容器问题"><a href="#常见的浏览器兼容器问题" class="headerlink" title="常见的浏览器兼容器问题"></a>常见的浏览器兼容器问题</h3><blockquote><p>1.不同的浏览器的默认标签的margin（外补丁）和padding（内补丁）都是不同的</p><p>解决方案：    使用css的<em>通配符设置 `</em>｛margin：0；padding：0；｝`</p><p>2.块元素设置浮动（float）后    ，又有横向的margin值，IE6中显示会比设置的大（IE6双边距bug）</p><p>解决方案： 在float标签样式控制中加入display:inline; </p><p>3.设置较小的高度标签（一般小于10px），在IE6，IE7，遨游中超出自己设置的高度 </p><p>解决方案： 给超出高度的标签设置overflow:hidden;或者设置行高line-height小于你设置的高度。 </p><p>4.行内标签设置display:block;后又采用float布局，再设置横向margin值时，在IE6中显示会比设置的大（IE6双边距bug） </p><p>解决方案： 在display:block;后面加上display:inline;display:table; </p><p>5.图片默认有间距 </p><p>解决方案： 使用float为img布局 </p><p>6.标签最低高度设置min-height不兼容 </p><p>解决方案： 例如要设置一个标签的最小高度为200px </p><p>7.透明度兼容设置 </p><p>解决方案：一句话</p><p>transparent_class {   </p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter:alpha(opacity=50);   </span><br><span class="line"></span><br><span class="line">   -moz-opacity:0.5;   </span><br><span class="line"></span><br><span class="line">   -khtml-opacity: 0.5;   </span><br><span class="line"></span><br><span class="line">   opacity: 0.5;   </span><br></pre></td></tr></tbody></table></figure><p> } </p></blockquote><h2 id="HTMl5部分"><a href="#HTMl5部分" class="headerlink" title="HTMl5部分"></a>HTMl5部分</h2><h3 id="1-请说说你对HTML标签语义化的理解？"><a href="#1-请说说你对HTML标签语义化的理解？" class="headerlink" title="1.请说说你对HTML标签语义化的理解？"></a>1.请说说你对HTML标签语义化的理解？</h3><blockquote><p>html5语义化指：根据内容的解构化，选择合适的语义化标签，便于开发者阅读和写出优雅的代码，同时让浏览器和爬虫更好的解析。</p></blockquote><h3 id="2-页面导入样式时，使用link和-import有什么区别？"><a href="#2-页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="2. 页面导入样式时，使用link和@import有什么区别？"></a>2. 页面导入样式时，使用link和@import有什么区别？</h3><blockquote><h4 id="1-属性不同"><a href="#1-属性不同" class="headerlink" title="1.属性不同"></a>1.属性不同</h4><p>link是html提供的标签，不仅可以加载css文件，还能定义RSS、rel连接属性。而@import是css的语法规则</p><h4 id="2-加载顺序不同"><a href="#2-加载顺序不同" class="headerlink" title="2.加载顺序不同"></a>2.加载顺序不同</h4><p>页面加载时，link引用的css文件被加载。而@import引用的css等页面加载完后最后加载</p><h4 id="3-兼容问题"><a href="#3-兼容问题" class="headerlink" title="3.兼容问题"></a>3.兼容问题</h4><p>@import是css2.1提出的，而link不存在兼容问题</p><h4 id="DOM控制性"><a href="#DOM控制性" class="headerlink" title="DOM控制性"></a>DOM控制性</h4><p>js操作DOM，可以使用link改变样式，无法使用@import方法使用样式</p></blockquote><h3 id="3-cookies，sessionStorage和localStorage的区别？"><a href="#3-cookies，sessionStorage和localStorage的区别？" class="headerlink" title="3. cookies，sessionStorage和localStorage的区别？"></a>3. cookies，sessionStorage和localStorage的区别？</h3><blockquote><p>cookies：存储大小不会好过4kb，失效时间：一般默认浏览器关闭失效，可以自己设置时间</p><p>sessionStorage：保存的数据只能存在当前会话，当会话结束数据也随之消失</p><p>loalStorage：用于持久化本地存储，除非主动删除否则数据就永远存在</p></blockquote><h3 id="4-简述一下src与href的区别？"><a href="#4-简述一下src与href的区别？" class="headerlink" title="4. 简述一下src与href的区别？"></a>4. 简述一下src与href的区别？</h3><blockquote><p>src一般用于引入文件，href一般用于链接跳转</p></blockquote><h3 id="5-清除浮动的方法"><a href="#5-清除浮动的方法" class="headerlink" title="5.清除浮动的方法"></a>5.清除浮动的方法</h3><blockquote><p>1.给浮动的元素在其后面添加一个空标签，该标签设置一个clear：both样式</p><p>2.给浮动的元素的父元素添加一个overflow：hidden样式</p><p>3.使用伪元素清除浮动</p><p>4.使用双伪元素清除</p></blockquote><h3 id="6-display-有哪些值？说明他们的作用"><a href="#6-display-有哪些值？说明他们的作用" class="headerlink" title="6.display 有哪些值？说明他们的作用?"></a>6.display 有哪些值？说明他们的作用?</h3><blockquote><p>display：none：隐藏元素</p><p>display：block：此元素为块元素显示，此元素前后带有换行（独占一行）</p><p>display：inline—block：设置为行内元素</p><p>display：list-item：此元素作为列表显示</p><p>display：table：此元素作为块级列表显示</p></blockquote><h3 id="7-常见的兼容问题"><a href="#7-常见的兼容问题" class="headerlink" title="7.常见的兼容问题"></a>7.常见的兼容问题</h3><blockquote><p>1.png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理. </p><p>2.浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一</p><p>3.E6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大，在浮动元素上添加display：inline</p><p>4.图片标签默认有3像素的margin，解决方式：图片标签设置display：block</p></blockquote><h3 id="8-javascript的typeof返回哪些数据类型，split-join-的区别？"><a href="#8-javascript的typeof返回哪些数据类型，split-join-的区别？" class="headerlink" title="8. javascript的typeof返回哪些数据类型，split() join() 的区别？"></a>8. javascript的typeof返回哪些数据类型，split() join() 的区别？</h3><blockquote><p>undefined、String、boolean、number、  symbol、object、function。</p><p> split()用于分割字符串，返回一个数组 </p><p> join()用于连接多个字符或字符串，返回值为一个字符串     </p></blockquote><h3 id="9-如何阻止事件冒泡，以及-如何阻止默认事件？"><a href="#9-如何阻止事件冒泡，以及-如何阻止默认事件？" class="headerlink" title="9.如何阻止事件冒泡，以及 如何阻止默认事件？"></a>9.如何阻止事件冒泡，以及 如何阻止默认事件？</h3><blockquote><p> event.stopPropagation()()阻止事件冒泡</p><p> event.preventdefault()阻止默认事件。（或者返回一个false） </p></blockquote><h3 id="10-用原生js添加-删除-替换-插入到某个接点的方法？"><a href="#10-用原生js添加-删除-替换-插入到某个接点的方法？" class="headerlink" title="10.用原生js添加 删除 替换 插入到某个接点的方法？"></a>10.用原生js添加 删除 替换 插入到某个接点的方法？</h3><blockquote><p>js：<br>appendChild()<br>//添加</p><p>removeChild()<br>//删除节点</p><p>insertBefore（插入节点，被插节点）<br>//插入（前插后）</p><p>replaceChild（新节点,旧节点）<br>//替换（前替换后）</p><p>jq：<br>append() （旧节点添加新节点后面）<br>appendTo() （新节点添加到旧节点后面）<br>prepend() （旧节点添加新节点的前面）<br>prependTo() （新节点添加到旧节点的前面）<br>//添加</p><p>remove()<br>（//清空：） empty()<br>//删除</p><p>after() <strong>__</strong>// 旧节点后面插入 新节点<br>before()    <strong>__</strong>    //旧节点前面插入 新节点<br>insertAfter() <strong>____</strong>//新节点插到旧节点后<br>insertBefore()    <strong>_____</strong>//新节点插到旧节点前<br>//插入</p><p>replaceWith()<br>//替换</p></blockquote><h3 id="11-函数声明与函数表达式的区别"><a href="#11-函数声明与函数表达式的区别" class="headerlink" title="11.函数声明与函数表达式的区别"></a>11.函数声明与函数表达式的区别</h3><blockquote><p>函数声明</p><p>函数声明以function关键字开头，接着是函数名还有就是函数体</p><p>函数表达式</p><p>就是把一个函数赋值给一个变量，通过这个变量来调用函数</p></blockquote><h3 id="12-请说出三种减低页面加载时间的方法"><a href="#12-请说出三种减低页面加载时间的方法" class="headerlink" title="12.请说出三种减低页面加载时间的方法"></a>12.请说出三种减低页面加载时间的方法</h3><blockquote><p>1.代码压缩</p><p>2.使用图片懒加载</p><p>3.降低对服务的的请求</p><p>4.将样式表放在头部</p><p>5.将脚本放在尾部</p><p>6.避免CSS表达式</p><p>7.删除重复脚本</p></blockquote><h3 id="13-jquery中遍历节点的常用方法？"><a href="#13-jquery中遍历节点的常用方法？" class="headerlink" title="13.jquery中遍历节点的常用方法？"></a>13.jquery中遍历节点的常用方法？</h3><blockquote><p>jQuery有一个each（）方法，里面是要执行的函数，用途就是循环遍历获取到的节点</p><p>parent（），返回元素的直接父节点<br>parents（），返回元素的所有祖先元素</p><p>children：返回所有的元素子节点，可以传入参数<br>find：返回所选元素的后代元素一直向下寻找，直到找到最后一个后代，可以传入参数</p><p>siblings（）：获取同胞元素<br>next（）：获取下一个同胞元素<br>nextAll（）：获取元素后面所有紧随的同胞<br>prev（）：获取元素上一个同胞元素<br>prevAll（）：获取元素前面所有紧随的同胞</p><p>first（）：获取被选元素的首个元素<br>last（）：获取被选元素的最后一个元素<br>eq（）：根据索引号（从0开始），获取被选元素中的指定元素<br>filter（）：获取与参数匹配<br>not（）：获取不与参数匹配的所有元素</p></blockquote><h3 id="14-vux五种状态、vuex的特性是什么"><a href="#14-vux五种状态、vuex的特性是什么" class="headerlink" title="14.vux五种状态、vuex的特性是什么"></a>14.vux五种状态、vuex的特性是什么</h3><blockquote><p>vuex的五种状态：state、getter、action、mutation、 module</p><p>特性：stae就是存放数据的地方，类似一个仓库 , 特性就是当mutation修改了state的数据的时候，他会动态的去修改所有的调用这个变量的所有组件里面的值（ 若是store中的数据发生改变，依赖这个数据的组件也会发生更新 ）</p><p>vuex的优势</p><p>  状态管理工具 核心是响应式的做到数据管理, 一个页面发生数据变化。动态的改变对应的页面 </p></blockquote><h3 id="15-webpack和grunt-gulp的区别"><a href="#15-webpack和grunt-gulp的区别" class="headerlink" title="15.webpack和grunt/gulp的区别?"></a>15.webpack和grunt/gulp的区别?</h3><blockquote><p> Webpack与Gulp、Grunt没有什么可比性，它可以看作模块打包机，通过分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。 </p></blockquote><h3 id="16-一个页面从输入url到页面加载完成显示，这个过程做了什么？"><a href="#16-一个页面从输入url到页面加载完成显示，这个过程做了什么？" class="headerlink" title="16.一个页面从输入url到页面加载完成显示，这个过程做了什么？"></a>16.一个页面从输入url到页面加载完成显示，这个过程做了什么？</h3><blockquote><p>1.DNS解析，解析获取相应IP地址</p><p>2.建立tcp连接</p><p>3.发送Http报文</p><p>4.服务器处理请求并返回HTTP报文</p><p>5.浏览器解析渲染页面</p><p>6.断开连接（断开tcp连接）</p></blockquote><h3 id="17-document-ready-方法和window-onload有什么区别？"><a href="#17-document-ready-方法和window-onload有什么区别？" class="headerlink" title="17.$(document).ready()方法和window.onload有什么区别？"></a>17.$(document).ready()方法和window.onload有什么区别？</h3><blockquote><p>1.ready():先执行、load()：后执行</p><p>ready事件在DOM结构绘制完成之后就绘执行。这样能确保就算有大量的媒体文件没加载出来，JS代码一样可以执行。 </p><p>2.load事件必须等到网页中所有内容全部加载完毕之后才被执行。如果一个网页中有大量的图片的话，则就会出现这种情况：网页文档已经呈现出来，但由于网页数据还没有完全加载完毕，导致load事件不能够即时被触发。 </p></blockquote><h3 id="18-js常见的内存泄漏"><a href="#18-js常见的内存泄漏" class="headerlink" title="18.js常见的内存泄漏"></a>18.js常见的内存泄漏</h3><blockquote><p>内存泄漏是指当一块内存不再被应用程序使用，由于某种原因，这块内存没有返回给操作系统或者内存内存池对象现象。</p><p>1.闭包：例如函数A里面嵌套了函数B，函数B又间接的访问了函数A里面的变量，函数A里面的变量引用数最少为1，函数A里面所占用的变量就无法被回收。</p><p>2.意外的全局变量：在javascript非严格模式中未定义的变量会自动绑定在全局对象（window/global）,比如</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>{</span><br><span class="line"> bar = <span class="string">"sssssaa"</span>;</span><br><span class="line">}</span><br><span class="line">foo()</span><br></pre></td></tr></tbody></table></figure><p>foo()在执行的时候，由于内部变量没有定义，相当于windo.bar=”sssssaa”,函数执行完毕，本应该销毁回收的变量，却永久的保存在内存中。</p><p>3.定时器:与节点或数据关联计时器不在需要，node对象可以删除，整个回调函数不需要也可以删除。如果计时器回调函数仍然没有没回收（计时器停止才会被回收）。计时器仍继续执行就会造成内存泄漏。</p></blockquote><h3 id="19-has路由和history路由"><a href="#19-has路由和history路由" class="headerlink" title="19.has路由和history路由"></a>19.has路由和history路由</h3><blockquote><p>has本来是用来做页面定位的，如果拿来做路由的话，原本的锚点功能就不能用了。其次，has的传参是基于url的，如果要传递复杂的数据，会有体积的限制，而history模式不仅可以在url里放参数，还可以将数据存放到一个特定的对象中放到一个特定的对象中。</p></blockquote><h3 id="20-router和route"><a href="#20-router和route" class="headerlink" title="20.router和route"></a>20.router和route</h3><blockquote><p>1.$router是Vuerouter的一个对象，通过Vue.use(Vuerouter)和Vue构造函数得到的一个router的实例对象，这个对象是一个全局对象，他包含了所有的所有路由，包含了许多关键字的对象和属性。$router.push({path:’home’}),本质是在添加一个history记录</p><p>$router.rqplace({path:’home’}),//替换路由，没有历史记录</p><p>2.$route是一个跳转的路由对象，每个路由都会有一个</p><p>$route对象，是一个局部对象，可以获取对应的name，path，params，query等参数信息</p></blockquote><h3 id="21-new关键字"><a href="#21-new关键字" class="headerlink" title="21.new关键字"></a>21.new关键字</h3><blockquote><p>1.开辟了一块内存空间 创建了一个新对象</p><p>2.让this指向了这个空对象</p><p>3.调用构造函数 给对象添加属性和方法</p><p>4.返回这个新对象</p></blockquote><h3 id="22-nextTick"><a href="#22-nextTick" class="headerlink" title="22.$nextTick"></a>22.$nextTick</h3><blockquote><p>问题：由于更新vue的变量后不会立即更新变量映射的dom，但是vue提供了$nextTick()方法，我们可以把希望在真实dom更新完成后执行的动作放在$nextTick</p></blockquote><h3 id="23-箭头函数"><a href="#23-箭头函数" class="headerlink" title="23.箭头函数"></a>23.箭头函数</h3><blockquote><p>1.箭头函数的this指向外层函数作用域的this。</p><p>2.箭头函数的this是定义函数时所在上下文中的this</p><p>3.箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象</p></blockquote><h3 id="24-vue的深度监听"><a href="#24-vue的深度监听" class="headerlink" title="24.vue的深度监听"></a>24.vue的深度监听</h3><blockquote><p>vue开启deep：true ，意味着开启了深度监听， 某个被监听的对象（引用类型数据）里面的任何数据发生变化都会触发handler函数</p></blockquote><h3 id="25-vue中绝对路径的配置（在vue-config-js中配置）"><a href="#25-vue中绝对路径的配置（在vue-config-js中配置）" class="headerlink" title="25.vue中绝对路径的配置（在vue.config.js中配置）"></a>25.vue中绝对路径的配置（在vue.config.js中配置）</h3><blockquote><p>1.引入node里的path模块</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br></pre></td></tr></tbody></table></figure><p>2.封装 <code>resolve</code>函数，使用  <code>__dirname</code>获取当前文件的所在目录</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> path.join(__dirname,dir)   <span class="comment">//path.join(__dirname) 设置绝对路径</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <code>__dirname</code>：当前配置的文件所在的绝对路径(双下划线)<br><code>dir</code>：传入的文件夹 </p><p>3.在 在<code>module.exports</code>中设置别名 </p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.expots = {</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    chainWebpack :<span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">        config.resolve.alias</span><br><span class="line">            .set(<span class="string">'@'</span>, resolve(<span class="string">'./src'</span>))</span><br><span class="line">            .set(<span class="string">'views'</span>,resolve(<span class="string">'./src/view'</span>))</span><br><span class="line">            .set(<span class="string">'assets'</span>,resolve(<span class="string">'./src/assets'</span>))</span><br><span class="line">            <span class="comment">//...可以继续自定义别名</span></span><br><span class="line">             <span class="comment">//set 第一个参数：设置的别名；第二个参数：原来默认的路径</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时<br> @：表示 ‘./src’<br> views: 表示 ‘./src/view’<br> assets: 表示 ‘./src/assets’<br> set 第一个参数：表示替换默认路径设置的别名；第二个参数：表示原来默认的路径</p><h5 id="vue-config-js中配置的全部代码"><a href="#vue-config-js中配置的全部代码" class="headerlink" title="vue.config.js中配置的全部代码"></a>vue.config.js中配置的全部代码</h5><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">dir</span>)</span>{</span><br><span class="line">    <span class="keyword">return</span> path.join(__dirname,dir)   <span class="comment">//path.join(__dirname) 设置绝对路径 双下划线</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.expots = {</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    chainWepack :<span class="function">(<span class="params">config</span>) =&gt;</span> {</span><br><span class="line">        config.resolve.alias</span><br><span class="line">            .set(<span class="string">'@'</span>, resolve(<span class="string">'./src'</span>))</span><br><span class="line">            .set(<span class="string">'views'</span>,resolve(<span class="string">'./src/view'</span>))</span><br><span class="line">            .set(<span class="string">'assets'</span>,resolve(<span class="string">'./src/assets'</span>))</span><br><span class="line">            <span class="comment">//...可以继续自定义别名</span></span><br><span class="line">             <span class="comment">//set 第一个参数：设置的别名；第二个参数：原来默认的路径</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><h3 id="26-vue单页面改多页面"><a href="#26-vue单页面改多页面" class="headerlink" title="26.vue单页面改多页面"></a>26.vue单页面改多页面</h3><blockquote><p>单页面改多页面链接： <a href="https://www.cnblogs.com/webhmy/p/10009364.html" target="_blank" rel="noopener">https://www.cnblogs.com/webhmy/p/10009364.html</a> </p><p>单页面改多页面链接： <a href="http://www.manongjc.com/article/19730.html" target="_blank" rel="noopener">http://www.manongjc.com/article/19730.html</a> </p></blockquote><h3 id="27-bind、call、apply（改变this的方法）区别"><a href="#27-bind、call、apply（改变this的方法）区别" class="headerlink" title="27.bind、call、apply（改变this的方法）区别"></a>27.bind、call、apply（改变this的方法）区别</h3><ul><li><p><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</p></li><li><p>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = {</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">}</span><br><span class="line">getValue.call(a, <span class="string">'yck'</span>, <span class="string">'24'</span>)</span><br><span class="line">getValue.apply(a, [<span class="string">'yck'</span>, <span class="string">'24'</span>])</span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p> <code>bind</code> 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 </p><p><code>bind</code> 实现柯里化 </p></blockquote><h3 id="28-另一个新大陆（你懂的！了解更多，请移步大佬专区）"><a href="#28-另一个新大陆（你懂的！了解更多，请移步大佬专区）" class="headerlink" title="28.另一个新大陆（你懂的！了解更多，请移步大佬专区）"></a>28.另一个新大陆（你懂的！了解更多，请移步大佬专区）</h3><blockquote><p> 链接：<a href="http://blog.poetries.top/FE-Interview-Questions/" target="_blank" rel="noopener">http://blog.poetries.top/FE-Interview-Questions/</a> </p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;undefine和null的区别&quot;&gt;&lt;a href=&quot;#undefine和null的区别&quot; class=&quot;headerlink&quot; title=&quot;undefine和null的区别&quot;&gt;&lt;/a&gt;undefine和null的区别&lt;/h3&gt;&lt;h4 id=&quot;undefined
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>阻止事件冒泡与阻止浏览器的默认行为</title>
    <link href="http://yoursite.com/2020/04/05/js-ting-zhi-shi-jian-mou-pao-zu-zhi-shi-jian-mou-pao-xing-wei-zu-zhi-a-biao-qian/"/>
    <id>http://yoursite.com/2020/04/05/js-ting-zhi-shi-jian-mou-pao-zu-zhi-shi-jian-mou-pao-xing-wei-zu-zhi-a-biao-qian/</id>
    <published>2020-04-05T07:47:18.015Z</published>
    <updated>2020-04-05T07:53:54.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js-阻止事件冒泡-阻止浏览器的默认行为（阻止超连接-）"><a href="#js-阻止事件冒泡-阻止浏览器的默认行为（阻止超连接-）" class="headerlink" title="js 阻止事件冒泡 阻止浏览器的默认行为（阻止超连接 # ）"></a><a href="https://www.cnblogs.com/yuzhongwusan/archive/2008/12/27/1363417.html" target="_blank" rel="noopener">js 阻止事件冒泡 阻止浏览器的默认行为（阻止超连接 # ）</a></h3><p>在前端开发工作中，由于浏览器兼容性等问题，我们会经常用到“停止事件冒泡”和“阻止浏览器默认行为”。 </p><h4 id="1-停止事件冒泡"><a href="#1-停止事件冒泡" class="headerlink" title="1.停止事件冒泡"></a>1.停止事件冒泡</h4><blockquote><p>JavaScript代码 </p><p>//如果提供了事件对象，则这是一个非IE浏览器<br>if ( e &amp;&amp; e.stopPropagation )<br>//因此它支持W3C的stopPropagation()方法<br>e.stopPropagation();<br>else<br>//否则，我们需要使用IE的方式来取消事件冒泡<br>window.event.cancelBubble = true;<br>return false; </p></blockquote><h4 id="阻止浏览器默认行为"><a href="#阻止浏览器默认行为" class="headerlink" title="阻止浏览器默认行为"></a>阻止浏览器默认行为</h4><blockquote><p>JavaScript代码 </p><p>//如果提供了事件对象，则这是一个非IE浏览器<br>if ( e &amp;&amp; e.preventDefault )<br>//阻止默认浏览器动作(W3C)<br>e.preventDefault();<br>else<br>//IE中阻止函数器默认动作的方式<br>window.event.returnValue = false;<br>return false; </p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;js-阻止事件冒泡-阻止浏览器的默认行为（阻止超连接-）&quot;&gt;&lt;a href=&quot;#js-阻止事件冒泡-阻止浏览器的默认行为（阻止超连接-）&quot; class=&quot;headerlink&quot; title=&quot;js 阻止事件冒泡 阻止浏览器的默认行为（阻止超连接 # ）&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/02/18/hello-world/"/>
    <id>http://yoursite.com/2020/02/18/hello-world/</id>
    <published>2020-02-18T13:11:55.808Z</published>
    <updated>2020-02-19T17:13:18.054Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
